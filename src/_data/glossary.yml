- term: "Assist"
  short_description: |-
    An automated, local code edit targeted at making common improvements to code.
  long_description: |-
    An assist is an automated, local code edit targeted at making common
    improvements to code.
    Examples of assists include converting `switch` statements to `switch`
    expressions, reversing the `then` and `else` blocks in an `if` statement,
    and inserting widgets into a widget structure.
  related_links:
    - text: "Refactor"
      link: "#refactor"
  labels:
    - "tools"
    - "analyzer"
  alternate:
    - "Quick assist"

- term: "Constant context"
  short_description: |-
    A region of code where the const keyword is implied and
    everything within that region must be a constant.
  long_description: |-
    A _constant context_ is a region of code in which it
    isn't necessary to include the `const` keyword because it's implied by 
    the fact that everything in that region is required to be a constant.
    The following locations are constant contexts:

    - Everything inside a list, map or set literal that's prefixed by
      the `const` keyword. For example:

      ```dart
      var l = const [/*constant context*/];
      ```

    - The arguments inside an invocation of a constant constructor.
      For example:

      ```dart
      var p = const Point(/*constant context*/);
      ```
  
    - The initializer for a variable that's prefixed by the `const` keyword.
      For example:

      ```dart
      const v = /*constant context*/;
      ```

    - Annotations.

    - The expression in a `case` clause. For example:

      ```dart
      void f(int e) {
        switch (e) {
          case /*constant context*/:
            break;
        }
      }
      ```
  related_links:
    - text: "Final and const variables"
      link: "/language/variables#final-and-const"
    - text: "Don't use const redundantly"
      link: "/effective-dart/usage#dont-use-const-redundantly"
  labels:
    - "language"
    - "const"
    - "understanding diagnostics"
  alternate:
    - "Implicit const"

- term: "Definite assignment"
  short_description: |-
    The determination of whether a variable has definitely been
    assigned a value before it's used.
  long_description: |-
    Definite assignment analysis is the process of determining, for each
    local variable at each point in the code, which of the following is true:

    - The variable has definitely been assigned a value
      (_definitely assigned_).
    - The variable has definitely not been assigned a value
      (_definitely unassigned_).
    - The variable might or might not have been assigned a value,
      depending on the execution path taken to arrive at that point.

    Definite assignment analysis helps find problems in code,
    such as places where a variable that might not have been
    assigned a value is being referenced, or
    places where a variable that can only be assigned a value one time is
    being assigned after it might already have been assigned a value.

    For example, in the following code the variable `s` is
    definitely unassigned when it's passed as an argument to `print`:

    ```dart
    void f() {
      String s;
      print(s);
    }
    ```

    But in the following code, the variable `s` is definitely assigned:

    ```dart
    void f(String name) {
      String s = 'Hello $name!';
      print(s);
    }
    ```

    Definite assignment analysis can even tell whether
    a variable is definitely assigned (or unassigned) when
    there are multiple possible execution paths.
    In the following code the `print` function is called if
    execution goes through either the true or the false branch of the
    `if` statement, but because `s` is assigned no matter which branch is taken,
    it's definitely assigned before it's passed to `print`:

    ```dart
    void f(String name, bool casual) {
      String s;
      if (casual) {
        s = 'Hi $name!';
      } else {
        s = 'Hello $name!';
      }
      print(s);
    }
    ```

    In flow analysis, the end of the `if` statement is referred to
    as a _join_â€”a place where two or more execution paths merge back together.
    Where there's a join, the analysis says that
    a variable is definitely assigned if it's definitely assigned along
    all of the paths that are merging, and definitely unassigned if
    it's definitely unassigned along all of the paths.

    Sometimes a variable is assigned a value on one path but not on another,
    in which case the variable might or might not have been assigned a value.
    In the following example, the true branch of the `if` statement might or
    might not be executed, so the variable might or might be assigned a value:

    ```dart
    void f(String name, bool casual) {
      String s;
      if (casual) {
        s = 'Hi $name!';
      }
      print(s);
    }
    ```

    The same is true if there is a false branch that
    doesn't assign a value to `s`.

    The analysis of loops is a little more complicated,
    but it follows the same basic reasoning.
    For example, the condition in a `while` loop is always executed,
    but the body might or might not be. So just like an `if` statement,
    there's a join at the end of the `while` statement between
    the path in which the condition is `true` and
    the path in which the condition is `false`.
  related_links:
    - text: "Definite assignment specification"
      link: "https://github.com/dart-lang/language/blob/main/resources/type-system/flow-analysis.md"
    - text: "Understanding definite assignment analysis"
      link: "/null-safety/understanding-null-safety#definite-assignment-analysis"
  labels:
    - "language"
    - "flow analysis"
    - "understanding diagnostics"

- term: "Function"
  short_description: |-
    An umbrella term to refer to top-level functions, local functions,
    static methods, and instance methods.
  related_links:
    - text: "Functions overview"
      link: "/language/functions"
    - text: "Instance methods"
      link: "/language/methods"
  labels:
    - "language"
    - "umbrella term"
  alternate:
    - "Procedure"

- term: "Irrefutable pattern"
  short_description: |-
    A pattern that always matches.
  long_description: |-
    _Irrefutable patterns_ are patterns that always match.
    Irrefutable patterns are the only patterns that can appear in
    _irrefutable contexts_: the [_declaration_][] and [_assignment_][]
    pattern contexts.

    [_declaration_]: /language/patterns#variable-declaration
    [_assignment_]: /language/patterns#variable-assignment
  related_links:
    - text: "Places patterns can appear"
      link: "/language/patterns#places-patterns-can-appear"
    - text: "Dive into Dart patterns and records"
      link: "https://codelabs.developers.google.com/codelabs/dart-patterns-records"
  labels:
    - "language"
    - "patterns"
  alternate:
    - "irrefutable context"

- term: "Mixin application"
  short_description: |-
    A class created when a mixin is applied to a class.
  long_description: |-
    A _mixin application_ is the class created when
    a mixin is applied to a class.
    For example, consider the following declarations:

    ```dart
    class A {}

    mixin M {}

    class B extends A with M {}
    ```

    The class `B` is a subclass of the mixin application of `M` to `A`,
    sometimes nomenclated as `A+M`. The class `A+M` is a subclass of `A` and
    has members that are copied from `M`.

    You can give an actual name to a mixin application by defining it as:

    ```dart
    class A {}

    mixin M {}

    class A_M = A with M;
    ```

    Given this declaration of `A_M`, the following declaration of `B` is
    equivalent to the declaration of `B` in the original example:

    ```dart
    class B extends A_M {}
    ```
  related_links:
    - text: "Mixins in Dart"
      link: "/language/mixins"
  labels:
    - "language"
    - "understanding diagnostics"
  alternate:
    - "with mixin"

- term: "Override inference"
  short_description: |-
    How missing types in a method declaration are inferred.
  long_description: |-
    Override inference is the process by which any missing types in
    a method declaration are inferred based on the corresponding types from
    the method or methods that it overrides.

    If a candidate method (the method that's missing type information)
    overrides a single inherited method, then the
    corresponding types from the overridden method are inferred.
    For example, consider the following code:

    ```dart
    class A {
      int m(String s) => 0;
    }

    class B extends A {
      @override
      m(s) => 1;
    }
    ```

    The declaration of `m` in `B` is a candidate because
    it's missing both the return type and the parameter type.
    Because it overrides a single method (the method `m` in `A`),
    the types from the overridden method will be used to infer
    the missing types and it will be as if the method in `B` had been
    declared as `int m(String s) => 1;`.

    If a candidate method overrides multiple methods, and
    the function type one of those overridden methods, M<sub>s</sub>,
    is a supertype of the function types of all of the other overridden methods,
    then M<sub>s</sub> is used to infer the missing types.
    For example, consider the following code:

    ```dart
    class A {
      int m(num n) => 0;
    }

    class B {
      num m(int i) => 0;
    }

    class C implements A, B {
      @override
      m(n) => 1;
    }
    ```

    The declaration of `m` in `C` is a candidate for override inference because
    it's missing both the return type and the parameter type.
    It overrides both `m` in `A` and `m` in `B`, so the compiler needs to
    choose one of them from which the missing types can be inferred.
    But because the function type of `m` in `A` (`int Function(num)`) is
    a supertype of the function type of `m` in `B` (`num Function(int)`),
    the function in `A` is used to infer the missing types. The result is
    the same as declaring the method in `C` as `int m(num n) => 1;`.

    It is an error if none of the overridden methods have a function type that
    is a supertype of all the other overridden methods.
  related_links:
    - text: "Inheritance in Dart"
      link: "/language/extend"
  labels:
    - "language"
    - "type inference"
    - "understanding diagnostics"

- term: "Part file"
  short_description: |-
    A Dart source file that contains a `part of` directive.
  long_description: |-
    A part file is a Dart source file that contains a `part of` directive
    and is included in a library using the `part` directive.
  related_links:
    - text: "Guidance on libraries and parts"
      link: "/guides/libraries/create-packages#organizing-a-package"
    - text: "Use library URIs in `part of` directives"
      link: "/effective-dart/usage#do-use-strings-in-part-of-directives"
  labels:
    - "language"
    - "libraries"
  alternate:
    - "part"

- term: "Potentially non-nullable"
  short_description: |-
    A type that is either non-nullable explicitly or
    due to being a type parameter.
  long_description: |-
    A type is _potentially non-nullable_ if it's either
    explicitly non-nullable or if it's a type parameter.

    A type is explicitly non-nullable if it is a
    type name that isn't followed by a question mark (`?`).
    Note that there are a few types that are always nullable, such as
    `Null` and `dynamic`, and that `FutureOr` is only non-nullable if
    it isn't followed by a question mark _and_
    the type argument is non-nullable (such as `FutureOr<String>`).

    Type parameters are potentially non-nullable because the actual
    runtime type (the type specified as a type argument) might be non-nullable.
    For example, given a declaration of `class C<T> {}`,
    the type `C` could be used with a non-nullable type argument as in `C<int>`.
  related_links:
    - text: "Nullability and generics"
      link: "/null-safety/understanding-null-safety#nullability-and-generics"
  labels:
    - "language"
    - "type system"
    - "flow analysis"
    - "understanding diagnostics"
  alternate:
    - "potentially nullable"

- term: "Public library"
  short_description: |-
    A library that is located in a package's `lib` directory but
    not inside the `lib/src` directory.
  long_description: |-
    A public library is a library that is located inside the package's `lib`
    directory but not inside the `lib/src` directory.
  related_links:
    - text: "Organizing a package's libraries"
      link: "/guides/libraries/create-packages#organizing-a-package"
    - text: "Public package directories"
      link: "/tools/pub/package-layout#public-directories"
  labels:
    - "language"
    - "libraries"

- term: "Quick fix"
  short_description: |-
    An automated, local code edit targeted at fixing the issue reported by a
    specific diagnostic.
  related_links:
    - text: "Quick fixes for analysis issues"
      link: "https://medium.com/dartlang/quick-fixes-for-analysis-issues-c10df084971a"
    - text: "Diagnostic messages"
      link: "/tools/diagnostic-messages"
    - text: "Linter rules"
      link: "/tools/linter-rules"
  labels:
    - "tools"
    - "understanding diagnostics"

- term: "Refactor"
  short_description: |-
    A code edit targeted at modifications that are either non-local or that
    require user interaction.
  long_description: |-
    A refactor is a code edit targeted at modifications that are either non-local
    or that require user interaction.
    Examples of refactors include renaming, removing, or extracting code.
  related_links:
    - text: "Assist"
      link: "#assist"
  labels:
    - "tools"
    - "analysis"

- term: "Refutable pattern"
  short_description: |-
    A pattern that can be tested against a value.
  long_description: |-
    A _refutable pattern_ is a pattern that can be tested against a value to
    determine if the pattern matches the value.
    If not, the pattern _refutes_, or denies, the match.
    Refutable patterns appear in [_matching contexts_][].

    [_matching contexts_]: /language/patterns#matching
  related_links:
    - text: "Places patterns can appear"
      link: "/language/patterns#places-patterns-can-appear"
    - text: "Dive into Dart patterns and records"
      link: "https://codelabs.developers.google.com/codelabs/dart-patterns-records"
  labels:
    - "language"
    - "patterns"
  alternate:
    - "matching contexts"

- term: "Subclass"
  short_description: |-
    A class that inherits the implementation of another class.
  long_description: |-
    A _subclass_ is a class that inherits the implementation of another class by
    using the [`extends`][] keyword, or by [mixin application][].

    ```dart
    // A is a subclass of B; B is the superclass of A.
    class A extends B {}

    // B1 has the superclass `A with M`, which has the superclass A.
    class B1 extends A with M {}
    ```

    A subclass relation also implies an associated [subtype](#subtype) relation.
    For example, `class A` implicitly defines an associated type `A`
    which instances of the class `A` inhabit.
    So, `class A extends B` declares not just that the class
    `A` is a subclass of `B`, but also establishes that the *type* `A` is a
    *subtype* of the type `B`.

    Subclass relations are a subset of subtype relations.
    When the documentation says "`S` must be a subtype of `T`",
    it's fine for `S` to be a subclass of `T`.
    However, the converse is not true: not all subtypes are subclasses.

    [`extends`]: /language/extend
    [mixin application]: #mixin-application
  related_links:
    - text: "Inheritance in Dart"
      link: "/language/extend"
    - text: "Subtype relationship"
      link: "#subtype"
  labels:
    - "language"
    - "type system"
  alternate:
    - "child class"

- term: "Subtype"
  short_description: |-
    A type that can be used wherever a value of its supertype is expected.
  long_description: |-
    A _subtype_ relation is where a value of a certain type is substitutable
    where the value of another type, the supertype, is expected.
    For example, if `S` is a subtype of `T`,
    then you can substitute a value of type `S`
    where a value of type `T` is expected.

    A subtype supports all of the operations of its supertype
    (and possibly some extra operations).
    In practice, this means you can assign the value of a subtype
    to any location expecting the supertype,
    and all of the methods of the supertype are available on the subtype.

    This is true at least statically.
    A specific API might not allow the substitution at run time,
    depending on its operations.

    Some subtype relations are based on the structure of the type,
    like with nullable types (for example, `int` is a subtype of `int?`)
    and function types
    (for example, `String Function()` is a subtype of `void Function()`).

    Subtypes can also be introduced for classes by
    [implementation](/language/classes#implicit-interfaces)
    or [inheritance](/language/extend) (direct or indirect):

    ```dart
    // A is a subtype of B, but NOT a subclass of B.
    class A implements B {}

    // C is a subtype AND a subclass of D.
    class C extends D {}
    ```
  related_links:
    - text: "Subclass"
      link: "#subclass"
    - text: "Substituting types"
      link: "/language/type-system#substituting-types"
  labels:
    - "language"
    - "type system"
  alternate:
    - "subtyping"
    - "subtype polymorphism"

- term: "Variance and variance positions"
  id: "variance"
  short_description: |-
    How changing a type argument of a type affects the relationship
    between the original type and the resulting one.

    In Dart, changing the type argument of a
    type declaration (like a class) or function return type, changes the
    overall type relationship in the same direction (covariant).

    However, changing the type of a function's parameter types, changes the
    overall type relationship in the opposite direction (contravariant).
  long_description: |-
    A type parameter of a class (or other type declaration, like a mixin) is
    said to be _covariant_ when the type as a whole
    "co-varies" with the actual type argument.
    In other words, if the type argument is replaced by a
    subtype then the type as a whole is also a subtype.

    For example, the type parameter of the class `List` is covariant because
    list types co-vary with their type argument: `List<int>` is a subtype of
    `List<Object>` because `int` is a subtype of `Object`.

    In Dart, all type parameters of all class, mixin,
    mixin class, and enum declarations are covariant.

    However, function types are different:
    A function type is covariant in its return type, but
    the opposite (known as _contravariant_) in its parameter types.
    For example, the type `int Function(int)` is a
    subtype of the type `Object Function(int)`, but it is a
    supertype of `int Function(Object)`.

    This makes sense if you consider their [substitutability](#subtype).
    If you call a function with a static type of `int Function(int)`,
    that function can actually be of type `int Function(Object)` at runtime.
    Based on the static type, you expect to be able to pass an `int` to it.
    That will be fine since the function actually accepts any `Object`,
    and this includes every object of type `int`.
    Similarly, the returned result will be of type `int`,
    which is also what you expect based on the static type.

    Hence, `int Function(Object)` is a subtype of `int Function(int)`.

    Note that everything is turned upside-down for parameter types.
    In particular, this subtype relation among function types requires that
    the _opposite_ subtype relation exists for the parameter type.
    For example, `void Function(Object)` is a subtype of `void Function(int)` 
    because `int` is a subtype of `Object`.

    With a more complex type like `List<void Function(int)>`,
    you have to consider the _positions_ in the type.
    To accomplish this, turn one of the parts of the type into a placeholder,
    and then consider what happens to the type when
    different types are placed in that position.

    For example, consider `List<void Function(_)>` as a template for
    a type where you can put different types in place of the placeholder `_`.
    This type is contravariant in the position where that placeholder occurs.

    The following illustrates this by substituting `Object` and `int` for `_`.
    `List<void Function(Object)>` is a subtype of `List<void Function(int)>`
    because `void Function(Object)` is a subtype of `void Function(int)` because
    `void` is a subtype of `void` (the return types) and
    `int` is a subtype of `Object` (the parameter types, in the opposite order).
    Hence, the type at `_` varies in the opposite direction of
    the type `List<void Function(_)>` as a whole, and this
    'opposite direction' by definition makes it a _contravariant position_.

    A _covariant position_ is defined similarly.
    For example, `_` is at a covariant position in the type `List<_>`,
    and `_` is also at a covariant position in the type `_ Function(int)`.

    There is yet another kind of position known as _invariant_,
    but it occurs much more rarely so the details are omitted here.

    In practice, it's often sufficient to know that
    the type arguments of a class, mixin, etc. are in a covariant position,
    and so is the return type of a function type, but
    the parameter types are in a contravariant position.
  related_links:
    - text: "Subtype relationship"
      link: "#subtype"
    - text: "Covariance and contravariance"
      link: "https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"
    - text: "The covariant keyword"
      link: "/guides/language/sound-problems#the-covariant-keyword"
  labels:
    - "language"
    - "type system"
    - "generics"
  alternate:
    - "variance positions"
    # TODO: Covariant and contravariant could/should have their own entries.
    - "covariance"
    - "covariant"
    - "contravariance"
    - "contravariant"

- term: "Version constraint"
#  short_description: |-
#    TODO
  long_description: |-
    A constraint placed on each [dependency][] of a package that specifies which
    versions of that dependency the package is expected to work with. 
    This can be a single version (`0.3.0`) or a range of versions (`^1.2.1`).
    While `any` is also allowed,
    for performance reasons the Dart team doesn't recommend it.

    [Packages][] should always specify version constraints
    for all of their dependencies.
    [Application packages][], on the other hand, should usually
    allow any version of their dependencies, since they use
    the [lockfile][] to manage their dependency versions.

    [dependency]: #dependency
    [Packages]: #package
    [Application packages]: #application-package
    [lockfile]: #lockfile
  related_links:
    - text: "Dart package version constraints"
      link: "/tools/pub/dependencies#version-constraints"
    - text: "Pub versioning philosophy"
      link: "/tools/pub/versioning"
  labels:
    - "packages"
    - "versioning"
    - "dependencies"
    - "pubspec"
  alternate:
    - "dependency constraint"

- term: "Verified publisher"
  short_description: |-
    One or more users who own a set of packages.
    Each verified publisher is identified by a verified domain name,
    such as **dart.dev**.
  related_links:
    - text: "Verified publishers"
      link: "/tools/pub/verified-publishers"
    - text: "Creating a verified publisher"
      link: "/tools/pub/publishing#verified-publisher"
    - text: "Dart team publishers"
      link: "/resources/dart-team-packages"
  labels:
    - "packages"
    - "publishing"
    - "pub.dev"

- term: "Uploader"
#  short_description: |-
#    TODO
  long_description: |-
    Someone who has administrative permissions for a package.
    A package uploader can upload new versions of the package, 
    and they can also [add and remove other uploaders][] for that package. 

    If a package has a verified publisher,
    then all members of the publisher can upload the package.

    [add and remove other uploaders]: /tools/pub/publishing#uploaders
  related_links:
    - text: "Verified publishers"
      link: "/tools/pub/verified-publishers"
    - text: "Package publishing"
      link: "/tools/pub/publishing"
  labels:
    - "packages"
    - "publishing"
    - "pub.dev"

- term: "Transitive dependency"
#  short_description: |-
#    TODO
  long_description: |-
    A dependency that your package indirectly uses because
    one of its dependencies requires it.
    If your package depends on A, which in turn depends on B which
    depends on C, then A is an [immediate dependency][] while
    B and C are transitive ones.

    [immediate dependency]: #immediate-dependency
  related_links:
    - text: "Package dependencies"
      link: "/tools/pub/dependencies"
  labels:
    - "packages"
    - "versioning"
    - "dependencies"

- term: "Pub system cache"
#  short_description: |-
#    TODO
  long_description: |-
    When pub gets a remote package,
    it downloads it into a single _system cache_ directory maintained by
    pub. On Mac and Linux, this directory defaults to `~/.pub-cache`.
    On Windows, the directory defaults to `%LOCALAPPDATA%\Pub\Cache`,
    though its exact location may vary depending on the Windows version.
    You can specify a different location using the
    [`PUB_CACHE`][] environment variable.

    Once packages are in the system cache,
    pub creates a `package_config.json` file that maps each package
    used by your application to the corresponding package in the cache.

    You only have to download a given version of a package once
    and can then reuse it in as many packages as you would like.
    If you specify the `--offline` flag to use cached packages,
    you can delete and regenerate your `package_config.json`
    files without having to access the network.

    [`PUB_CACHE`]: /tools/pub/environment-variables
  related_links:
    - text: "The system package cache"
      link: "/tools/pub/cmd/pub-get#the-system-package-cache"
  labels:
    - "packages"
    - "package config"
    - "cache"
  alternate:
   - "system package cache"

- term: "Dependency source"
#  short_description: |-
#    TODO
  long_description: |-
    A kind of place that pub can get packages from. A source isn't
    a specific place like the pub.dev site or some specific Git URL.
    Each source describes a general procedure for
    accessing a package in some way.
    For example, _git_ is one source.
    The git source knows how to download packages given a Git URL.
    Several different [supported sources][] are available.

    [supported sources]: /tools/pub/dependencies#dependency-sources
  related_links:
    - text: "Pub dependency source reference"
      link: "/tools/pub/dependencies#dependency-sources"
  labels:
    - "packages"
    - "pubspec"
    - "dependencies"
    - "versioning"
  alternate:
    - "package source"
    - "dependency source"
    - "pub source"

- term: "SDK constraint"
#  short_description: |-
#    TODO
  long_description: |-
    The declared versions of the Dart SDK itself that
    a package declares that it supports. An SDK constraint is specified using
    normal [version constraint](#version-constraint) syntax, but in a
    special _environment_ section [in the pubspec][environment constraints].

    [environment constraints]: /tools/pub/pubspec#sdk-constraints
  related_links:
    - text: "Pubspec SDK constraints"
      link: "/tools/pub/pubspec#sdk-constraints"
  labels:
    - "packages"
    - "pubspec"
    - "sdk"
    - "versioning"
  alternate:
    - "dart constraint"
    - "flutter version constraint"

- term: "Package"
#  short_description: |-
#    TODO
  long_description: |-
    A collection of [libraries] under a directory,
    with a [pubspec.yaml] in the root of that directory. 

    Packages can have [dependencies](#dependency) on other packages
    *and* can be dependencies themselves.
    A package's `/lib` directory contains the
    [public libraries][] that other packages can import and use.
    They can also include scripts to be run directly.
    A package that is not intended to be depended on by other packages is an
    [application package][].
    Shared packages are [published][] to pub.dev,
    but you can also have non-published packages.

    Don't check the [lockfile][] of a package into source
    control, since libraries should support a range of dependency versions.
    The [version constraints][] of a package's
    [immediate dependencies][] should be as wide as possible while still
    ensuring that the dependencies will be compatible with the versions that
    were tested against.

    Since [semantic versioning][] requires that libraries increment their
    major version numbers for any backwards incompatible changes,
    packages will usually require their dependencies' versions to be
    greater than or equal to the versions that were tested and
    less than the next major version. So if your library
    depended on the (fictional) `transmogrify` package and you tested it at
    version 1.2.1, your version constraint would be [`^1.2.1`][].

    [libraries]: #library
    [pubspec.yaml]: /tools/pub/pubspec
    [public libraries]: /tools/pub/package-layout#public-libraries
    [application package]: #application-package
    [published]: /tools/pub/publishing
    [lockfile]: #lockfile
    [version constraints]: #version-constraint
    [immediate dependencies]: #immediate-dependency
    [semantic versioning]: https://semver.org/spec/v2.0.0-rc.1.html
    [`^1.2.1`]: /tools/pub/dependencies#caret-syntax
  related_links:
    - text: "How to use packages"
      link: "/guides/packages"
  labels:
    - "packages"
    - "libraries"
    - "dependencies"
  alternate:
    - "library package"

- term: "Lockfile"
#  short_description: |-
#    TODO
  long_description: |-
    A file named `pubspec.lock` that specifies the concrete versions and
    other identifying information for every immediate and transitive dependency
    a package relies on.

    Unlike the pubspec, which only lists immediate dependencies and
    allows version ranges, the lockfile comprehensively pins down
    the entire dependency graph to specific versions of packages.
    A lockfile ensures that you can recreate the
    exact configuration of packages used by an application.

    The lockfile is generated automatically for you by pub when you run
    [`pub get`](/tools/pub/cmd/pub-get),
    [`pub upgrade`](/tools/pub/cmd/pub-upgrade),
    or [`pub downgrade`](/tools/pub/cmd/pub-downgrade).
    Pub includes a [content hash][] for each package
    to check against during future resolutions.

    If your package is an [application package][], you will
    typically check this into source control.
    For regular packages, you usually won't.

    [content hash]: #content-hash
  labels:
    - "packages"
    - "libraries"
    - "dependencies"
    - "pubspec"
  alternate:
    - "pubspec.lock"
    - "pub lock"
    - "lock file"

- term: "Library"
  short_description: |-
    A library is a single compilation unit, made up of a single primary file and
    any optional number of [parts][]. Libraries have their own private scope.

    [parts]: /resources/glossary#part-file
#  long_description: |-
#    TODO
  related_links:
    - text: "Libraries & imports"
      link: "/language/libraries"
  labels:
    - "language"
    - "packages"
    - "imports"
  alternate:
    - "libraries"

- term: "Immediate dependency"
  short_description: |-
    A [dependency](#dependency) that your package directly uses itself.
    The dependencies you list in your pubspec are
    your package's immediate dependencies. All other dependencies are
    [transitive dependencies](#transitive-dependency).
  related_links:
    - text: "Package dependencies"
      link: "/tools/pub/dependencies"
  labels:
    - "packages"
    - "versioning"
    - "dependencies"
  alternate:
    - "direct dependency"

- term: "Entrypoint directory"
  short_description: |-
    A directory inside your package that is allowed to contain Dart entrypoints.
  long_description: |-
    A directory inside your package that is allowed to contain
    [Dart entrypoints](#entrypoint).

    Pub has a list of these directories: `benchmark`, `bin`, `example`,
    `test`, `tool`, and `web` (and `lib`, for [Flutter apps][]).
    Any subdirectories of those (except `bin`) may also contain entrypoints.

    [Flutter apps]: https://docs.flutter.dev/packages-and-plugins/developing-packages
  labels:
    - "packages"
    - "tools"
    - "bin"
  alternate:
    - "direct dependency"

- term: "Entrypoint"
#  short_description: |-
#    TODO
  long_description: |-
    In the general context of Dart, an _entrypoint_ is
    a Dart library that is directly invoked by a Dart implementation.
    When you reference a Dart library in a `<script>` tag or
    pass it as a command-line argument to the standalone Dart VM,
    that library is the entrypoint.
    In other words, it's usually the `.dart` file that contains `main()`.

    In the context of pub, an _entrypoint package_ or _root package_ is
    the root of a dependency graph. It will usually be an application.
    When you run your app, it's the entrypoint package.
    Every other package it depends on will not be an entrypoint in that context.

    A package can be an entrypoint in some contexts and not in others. Say your
    app uses a package `A`. When you run your app, `A` is not the entrypoint
    package. However, if you go over to `A` and execute its tests, in that
    context, it *is* the entrypoint since your app isn't involved.
  labels:
    - "packages"
    - "tools"
    - "bin"
  alternate:
    - "Entrypoint package"
    - "Root package"
    - "Runnable library"

- term: "Dependency"
#  short_description: |-
#    TODO
  long_description: |-
    Another package that your package relies on.
    If your package wants to import code from some other package,
    that package must be a dependency.
    Dependencies are specified in your package's [pubspec][] and
    described in [Package dependencies][].

    To see the dependencies used by a package, use [`pub deps`][].

    [pubspec]: /tools/pub/pubspec
    [Package dependencies]: /tools/pub/dependencies
    [`pub deps`]: /tools/pub/cmd/pub-deps
  related_links:
    - text: "Package dependencies"
      link: "/tools/pub/dependencies"
  labels:
    - "packages"
    - "dependencies"
    - "package dependency"
    - "libraries"

- term: "Content hash"
#  short_description: |-
#    TODO
  long_description: |-
    The pub.dev repository maintains a sha256 hash of
    each package version it hosts.
    Pub clients can use this hash to
    validate the integrity of downloaded packages,
    and protect against changes on the repository. 

    When `dart pub get` downloads a package,
    it computes the hash of the downloaded archive.
    The hash of each hosted dependency is stored with the
    [resolution][] in the [lockfile][].

    The pub client uses this content hash
    to verify that running `dart pub get` again using the same lockfile,
    potentially on a different computer, uses exactly the same packages.

    If the locked hash doesn't match what's currently in the pub cache,
    pub redownloads the archive. If it still doesn't match, the lockfile
    updates and a warning is printed. For example:

    ```plaintext
    $ dart pub get
    Resolving dependencies...
    [!Cached version of foo-1.0.0 has wrong hash - redownloading.!]
     ~ foo 1.0.0 (was 1.0.0)
    [!The existing content-hash from pubspec.lock doesn't match contents for:!]
     * foo-1.0.0 from "pub.dev"
    This indicates one of:
     * The content has changed on the server since you created the pubspec.lock.
     * The pubspec.lock has been corrupted.

    [!The content-hashes in pubspec.lock has been updated.!]

    For more information see:
    https://dart.dev/go/content-hashes

    Changed 1 dependency!
    ```

    The updated content hash will show up in your version control diff,
    and should make you suspicious.

    To make a discrepancy become an error instead of a warning, use
    [`dart pub get --enforce-lockfile`][].
    The `--enforce-lockfile` option causes resolution to fail if
    pub can't find package archives with the same hashes,
    without updating the lockfile.

    ```plaintext
    $ dart pub get [!--enforce-lockfile!]
    Resolving dependencies...
    Cached version of foo-1.0.0 has wrong hash - redownloading.
    ~ foo 1.0.0 (was 1.0.0)
    The existing content-hash from pubspec.lock doesn't match contents for:
     * foo-1.0.0 from "pub.dev"

    This indicates one of:
     * The content has changed on the server since you created the pubspec.lock.
     * The pubspec.lock has been corrupted.

    For more information see:
    https://dart.dev/go/content-hashes
    [!Would change 1 dependency.!]
    [!Unable to satisfy `pubspec.yaml` using `pubspec.lock`.!]

    To update `pubspec.lock` run `dart pub get` without
    `--enforce-lockfile`.
    ```

    [resolution]: /tools/pub/cmd/pub-get
    [lockfile]: #lockfile
    [`dart pub get --enforce-lockfile`]: /tools/pub/cmd/pub-get#enforce-lockfile
  related_links:
    - text: "Enforce lockfile option"
      link: "/tools/pub/cmd/pub-get#enforce-lockfile"
  labels:
    - "packages"
    - "pubspec"
    - "pubspec.lock"
    - "dependencies"
  alternate:
    - "pub hash"
    - "checksum"

- term: "Application package"
#  short_description: |-
#    TODO
  long_description: |-
    A package that contains a program or app, with a [main entrypoint][]. 
    Meant to be run directly, either on the command line or in a browser.

    Application packages may have [dependencies][] on other packages,
    but are never depended on themselves.
    Unlike regular [packages][], they are not intended to be shared.

    Application packages should check their [lockfiles][] into source
    control, so that everyone working on the application and every location the
    application is deployed has a consistent set of dependencies. Because their
    dependencies are constrained by the lockfile, application packages usually
    specify `any` for their dependencies' [version constraints][].

    [main entrypoint]: #entrypoint
    [dependencies]: #dependency
    [packages]: #package
    [lockfiles]: #lockfile
    [version constraints]: #version-constraint
  labels:
    - "packages"
    - "apps"
    - "pubspec.lock"
  alternate:
    - "app package"
    - "app"